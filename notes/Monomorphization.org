* Monomorphization
 Monomorphization refers to the process of converting polymorphic code to
 monomorphic code (no type variables) through static analysis.

 Example:
 #+begin_src minijuvix
 id : (A : Type) ‚Üí A ‚Üí A;
 id _ a ‚âî a;

 b : Bool;
 b ‚âî id Bool true;

 n : Nat;
 n ‚âî id Nat zero;
 #+end_src

 Is translated into:
 #+begin_src minijuvix
 id_Bool : Bool ‚Üí Bool;
 id_Bool a ‚âî a;

 id_Nat : Nat ‚Üí Nat;
 id_Nat a ‚âî a;
 #+end_src

* More examples
** Mutual recursion
#+begin_src minijuvix
inductive List (A : Type) {
  nil : List A;
  cons : A ‚Üí List A ‚Üí List A;
};

even : (A : Type) ‚Üí List A ‚Üí Bool;
even A nil ‚âî true ;
even A (cons _ xs) ‚âî not (odd A xs) ;

odd : (A : Type) ‚Üí List A ‚Üí Bool;
odd A nil ‚âî false ;
odd A (cons _ xs) ‚âî not (even A xs) ;

-- main ‚âî even Bool ..  odd Nat;
#+end_src

* Algorithm
** Assumptions:
1. Type abstractions only appear at the leftmost part of a type signature.
2. All functions and constructors are fully type-applied: i.e. currying for
   types is not supported.
3. The =main= function is the entry point and has a concrete type.
4. All axioms are monomorphic.

** Definitions
1. *Application*. An application is an expression of the form =t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô= with n > 0.

2. *Sub application*. If =t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô= is an application then for every =0<i<n=
   =t‚ÇÅ t‚ÇÇ ‚Ä¶ t·µ¢= is a sub application.

Fix a minijuvix program =P=. Let =ùí≤= be the set of all applications that appear in =P=.
1. *Proper application*. A proper application is an application =A‚ààùí≤= such that
   for every =A'‚ààùí≤= we have that =A= is *not* a sub application of =A'=.

2. *Type application*. If =t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô= is a proper application and =a‚ÇÅ, ‚Ä¶, a‚Çò=
   and =a‚Çò‚Çä‚ÇÅ= is not a type or =m=n= are types, then =t a‚ÇÅ, ‚Ä¶, a‚Çò= is a type
   application.

3. *Concrete type*. A type is concrete if it involves no type variables.

4. *Concrete type application*. A type application =t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô= if =a‚ÇÅ, a‚ÇÇ, ‚Ä¶,
   a‚Çô= are concrete types.

** Option 1
  Gather all type applications in =main=. Since =main= type is concrete, these
  type applications are all concrete. We now have a stack =c‚ÇÅ, c‚ÇÇ, ‚Ä¶, c‚Çô= of
  concrete type applications.
  1. If the stack is empty, we are done.
  2. Otherwise pop =c‚ÇÅ= from the stack. It will be of the form =t a‚ÇÅ ‚Ä¶ a‚Çò=,
     where =t= is either a constructor or a function and =a‚ÇÅ, ‚Ä¶, a‚Çò= are
     concrete types.
  3. If the instantiation =t a‚ÇÅ ‚Ä¶ a‚Çò= has already been registered go to step 1.
     Otherwise continue to the next step.
  4. Register the instantiation =t a‚ÇÅ ‚Ä¶ a‚Çò=.
  5. If =t= is a constructor continue to step 1.
  6. If =t= is a function, then it has type variables =v‚ÇÅ, ‚Ä¶, v‚Çò=.
     Consider the substitution =œÉ = {v‚ÇÅ ‚Ü¶ a‚ÇÅ, ‚Ä¶, v‚Çò ‚Ü¶ a‚Çò}=.
     Consider the list of type applications in the body of =t=: =d‚ÇÅ, ‚Ä¶,d·µ£=.
     Add =œÉ(d‚ÇÅ), ‚Ä¶, œÉ(d·µ£)= to the stack and continue to step 1.
     It is easy to see that for any =i=, =œÉ(d·µ¢)= is a concrete type application.

*** Correctness
   It should be clear that the algorithm terminates and registers all
   instantiations of constructors and functions.
