module PolySimpleFungibleToken;

foreign ghc {
  import Anoma
};

--------------------------------------------------------------------------------
-- Booleans
--------------------------------------------------------------------------------

inductive Bool {
  true : Bool;
  false : Bool;
};

infixr 2 ||;
|| : Bool → Bool → Bool;
|| false a ≔ a;
|| true _ ≔ true;

infixr 3 &&;
&& : Bool → Bool → Bool;
&& false _ ≔ false;
&& true a ≔ a;

if : (A : Type) → Bool → A → A → A;
if _ true a _ ≔ a;
if _ false _ b ≔ b;

--------------------------------------------------------------------------------
-- Backend Booleans
--------------------------------------------------------------------------------

axiom BackendBool : Type;

compile BackendBool {
  ghc ↦ "Bool";
};

axiom backend-true : BackendBool;
compile backend-true {
  ghc ↦ "True";
};

axiom backend-false : BackendBool;
compile backend-false {
  ghc ↦ "False";
};

--------------------------------------------------------------------------------
-- Backend Bridge
--------------------------------------------------------------------------------

foreign ghc {
  bool :: Bool -> a -> a -> a
  bool True x _ = x
  bool False _ y = y
};

axiom bool : BackendBool → Bool → Bool → Bool;
compile bool {
  ghc ↦ "bool";
};

from-backend-bool : BackendBool → Bool;
from-backend-bool bb ≔ bool bb true false;

--------------------------------------------------------------------------------
-- Functions
--------------------------------------------------------------------------------

const : (A : Type) → (B : Type) → A → B → A;
const _ _ a _ ≔ a;

id : (A : Type) → A → A;
id _ a ≔ a;

--------------------------------------------------------------------------------
-- Integers
--------------------------------------------------------------------------------

axiom Int : Type;
compile Int {
  ghc ↦ "Int";
};

infix 4 <';
axiom <' : Int → Int → BackendBool;
compile <' {
  ghc ↦ "(<)";
};

infix 4 <;
< : Int → Int → Bool;
< i1 i2 ≔ from-backend-bool (i1 <' i2);

axiom eqInt : Int → Int → BackendBool;
compile eqInt {
  ghc ↦ "(==)";
};

infix 4 ==Int;
==Int : Int → Int → Bool;
==Int i1 i2 ≔ from-backend-bool (eqInt i1 i2);

infixl 6 -;
axiom - : Int -> Int -> Int;
compile - {
  ghc ↦ "(-)";
};

infixl 6 +;
axiom + : Int -> Int -> Int;
compile + {
  ghc ↦ "(+)";
};

--------------------------------------------------------------------------------
-- Strings
--------------------------------------------------------------------------------

axiom String : Type;
compile String {
  ghc ↦ "[Char]";
};

axiom eqString : String → String → BackendBool;
compile eqString  {
  ghc ↦ "(==)";
};

infix 4 ==String;
==String : String → String → Bool;
==String s1 s2 ≔ from-backend-bool (eqString s1 s2);

--------------------------------------------------------------------------------
-- Lists
--------------------------------------------------------------------------------

inductive List (A : Type) {
  nil : List A;
  cons : A → List A → List A;
};

elemGen : (A : Type) → (A → A → Bool) → A → List A → Bool;
elemGen _ _ _ nil ≔ false;
elemGen A eq s (cons x xs) ≔ eq s x || elemGen A eq s xs;

elem : String → List String → Bool;
elem s l ≔ elemGen String (==String) s l;

foldl : (A : Type) → (B : Type) → (B → A → B) → B → List A → B;
foldl _ _ f z nil ≔ z;
foldl A B f z (cons h hs) ≔ foldl A B f (f z h) hs;

--------------------------------------------------------------------------------
-- Pair
--------------------------------------------------------------------------------

-- inductive PairIntBool {
--   MakePair : Int → Bool → PairIntBool;
-- };

inductive Pair (A : Type) (B : Type) {
  mkPair : A → B → Pair A B;
};

if-pairIntBool : Bool → Pair Int Bool → Pair Int Bool → Pair Int Bool;
if-pairIntBool ≔ if (Pair Int Bool);

--------------------------------------------------------------------------------
-- Maybe
--------------------------------------------------------------------------------

inductive Maybe (A : Type) {
 nothing : Maybe A;
 just : A → Maybe A;
};

if-optionInt : Bool → Maybe Int → Maybe Int → Maybe Int;
if-optionInt ≔ if (Maybe Int);

from-int : Int → Maybe Int;
from-int i ≔ if-optionInt (i < 0) (nothing Int) (just Int i);

maybe : (A : Type) → (B : Type) → B → (A → B) → Maybe A → B;
maybe _ _ b _ nothing ≔ b;
maybe _ _ _ f (just x) ≔ f x;

maybe-int : Int → Maybe Int → Int;
maybe-int d ≔ maybe Int Int d (id Int);

if-optionString : Bool → Maybe String → Maybe String → Maybe String;
if-optionString ≔ if (Maybe String);

from-string : String → Maybe String;
from-string s ≔ if-optionString (s ==String "") (nothing String) (just String s);

pair-from-optionString : (String → Pair Int Bool) → Maybe String → Pair Int Bool;
pair-from-optionString ≔ maybe String (Pair Int Bool) (mkPair Int Bool 0 false);

--------------------------------------------------------------------------------
-- foldl
--------------------------------------------------------------------------------

foldl' : (Pair Int Bool → String → Pair Int Bool) → Pair Int Bool → List String → Pair Int Bool;
foldl' ≔ foldl String (Pair Int Bool) ;

--------------------------------------------------------------------------------
-- Anoma
--------------------------------------------------------------------------------

axiom readPre : String → Int;
compile readPre {
  ghc ↦ "readPre";
};

axiom readPost : String → Int;
compile readPost {
  ghc ↦ "readPost";
};

axiom isBalanceKey : String → String → String;
compile isBalanceKey {
  ghc ↦ "isBalanceKey";
};

read-pre : String → Maybe Int;
read-pre s ≔ from-int (readPre s);

read-post : String → Maybe Int;
read-post s ≔ from-int (readPost s);

is-balance-key : String → String → Maybe String;
is-balance-key token key ≔ from-string (isBalanceKey token key);

unwrap-default : Maybe Int → Int;
unwrap-default o ≔ maybe-int 0 o;

--------------------------------------------------------------------------------
-- Validity Predicate
--------------------------------------------------------------------------------

change-from-key : String → Int;
change-from-key key ≔ unwrap-default (read-post key) - unwrap-default (read-pre key);

check-vp : List String → String → Int → String → Pair Int Bool;
check-vp verifiers key change owner ≔
    if-pairIntBool
        (change-from-key key < 0)
        -- make sure the spender approved the transaction
        (mkPair Int Bool (change + (change-from-key key)) (elem owner verifiers))
        (mkPair Int Bool (change + (change-from-key key)) true);

check-keys : String → List String → Pair Int Bool → String → Pair Int Bool;
check-keys token verifiers (mkPair change is-success) key ≔
    if-pairIntBool
        is-success
        (pair-from-optionString (check-vp verifiers key change) (is-balance-key token key))
        (mkPair Int Bool 0 false);

check-result : Pair Int Bool → Bool;
check-result (mkPair change all-checked) ≔ (change ==Int 0) && all-checked;

vp : String → List String → List String → Bool;
vp token keys-changed verifiers ≔
    check-result
        (foldl'
            (check-keys token verifiers)
            (mkPair Int Bool 0 true)
            keys-changed);

--------------------------------------------------------------------------------
-- IO
--------------------------------------------------------------------------------

axiom Action : Type;
compile Action {
 ghc ↦ "IO ()";
};

axiom putStr : String → Action;
compile putStr {
  ghc ↦ "putStr";
};

axiom putStrLn : String → Action;
compile putStrLn {
  ghc ↦ "putStrLn";
};

infixl 1 >>;
axiom >> : Action → Action → Action;
compile >> {
  ghc ↦ "(>>)";
};

show-result : Bool → String;
show-result true ≔ "OK";
show-result false ≔ "FAIL";

--------------------------------------------------------------------------------
-- Testing VP
--------------------------------------------------------------------------------

token : String;
token ≔ "owner-token";

owner-address : String;
owner-address ≔ "owner-address";

change1-key : String;
change1-key ≔ "change1-key";

change2-key : String;
change2-key ≔ "change2-key";

verifiers : List String;
verifiers ≔ cons String owner-address (nil String);

keys-changed : List String;
keys-changed ≔ cons String change1-key (cons String change2-key (nil String));

main : Action;
main ≔
    (putStr "VP Status: ")
    >> (putStrLn (show-result (vp token keys-changed verifiers)));

end;
