module Data.List;

import Data.Bool;
open Data.Bool;

import Data.Nat;
open Data.Nat;

inductive List (A : Type) {
  nil : List A;
  cons : A → List A → List A;
};

foldr : (A : Type) → (B : Type) → (A → B → B) → B → List A → B;
foldr _ _ _ z nil ≔ z;
foldr A B f z (cons h hs) ≔ f h (foldr A B f z hs);

foldl : (A : Type) → (B : Type) → (B → A → B) → B → List A → B;
foldl A B f z nil ≔ z ;
foldl A B f z (cons h hs) ≔ foldl A B f (f z h) hs;

map : (A : Type) → (B : Type) → (A → B) → List A → List B;
map _ B f nil ≔ nil B;
map A B f (cons h hs) ≔ cons B (f h) (map A B f hs);

filter : (A : Type) → (A → Bool) → List A → List A;
filter A f nil ≔ nil A;
filter A f (cons h hs) ≔ ite (List A) (f h)
  (cons A h (filter A f hs))
  (filter A f hs);

length : (A : Type) → List A → ℕ;
length _ nil ≔ zero;
length A (cons _ l) ≔ suc (length A l);

rev : (A : Type) → List A → List A → List A;
rev _ nil l ≔ l;
rev A (cons x xs) l ≔ rev A xs (cons A x l);

reverse : (A : Type) → List A → List A;
reverse A l ≔ rev A l (nil A);

replicate : (A : Type) → ℕ → A → List A;
replicate A zero _ ≔ nil A;
replicate A (suc n) x ≔ cons A x (replicate A n x);

take : (A : Type) → ℕ → List A → List A;
take A (suc n) (cons x xs) ≔ cons A x (take A n xs);
take A _ _ ≔ nil A;

concat : (A : Type) → List A → List A → List A;
concat A nil ys ≔ ys;
concat A (cons x xs) ys ≔ cons A x (concat A xs ys);

end;
