module Data.List;

import Data.Bool;
open Data.Bool;

-- infixr 5 ∷; waiting for implicit arguments
inductive List (a : Type) {
  nil : List a;
  ∷ : a → List a → List a;
};

foldr : (a : Type) → (b : Type) → (a → b → b) → b → List a → b;
foldr _ _ _ z (nil _) ≔ z;
foldr a b f z (∷ _ h hs) ≔ f h (foldr a b f z hs);

foldl : (a : Type) → (b : Type) → (b → a → b) → b → List a → b;
foldl a b f z (nil _) ≔ z ;
foldl a b f z (∷ _ h hs) ≔ foldl a b f (f z h) hs;

map : (a : Type) → (b : Type) → (a → b) → List a → List b;
map _ b f (nil _) ≔ nil b;
map a b f (∷ _ h hs) ≔ ∷ a (f h) (map a b f hs);

filter : (a : Type) → (a → Bool) → List a → List a;
filter a f (nil _) ≔ nil a;
filter a f (∷ _ h hs) ≔ ite (List a) (f h)
  (∷ a h (filter a f hs))
  (filter a f hs);

import Data.Nat;
open Data.Nat;

length : (a : Type) → List a → ℕ;
length _ (nil _) ≔ zero;
length a (∷ _ _ l) ≔ suc (length a l);

rev : (a : Type) → List a → List a → List a;
rev _ (nil _) l ≔ l;
rev a (∷ _ x xs) l ≔ rev a xs (∷ a x l);

reverse : (a : Type) → List a → List a;
reverse a l ≔ rev l (nil a);

replicate : (a : Type) → ℕ → a → List a;
replicate a zero _ ≔ nil a;
replicate a (suc n) x ≔ ∷ a x (replicate a n x);

take : (a : Type) → ℕ → List a → List a;
take a (suc n) (∷ _ x xs) ≔ ∷ a x (take a n xs);
take a _ _ ≔ nil a;

alternate : (a : Type) → List a → List a → List a;
alternate A (nil _) b ≔ b;
alternate A (∷ _ h t) b ≔ ∷ A h (alternate A b t);

-- import Data.Ord;
-- open Data.Ord;

-- import Data.Product;
-- open Data.Product;

-- splitAt : (a : Type) → ℕ → List a → List a;
-- splitAt a _ (nil _) ≔ nil a , nil a;
-- splitAt a zero xs ≔ , (List a) (List a) (nil a) xs;
-- splitAt a (suc zero) (∷ _ x xs) ≔ , (List a) (List a) (∷ a x (nil a)) xs;
-- splitAt a (suc (suc m)) (∷ _ x xs) ≔ match splitAt a m xs {
--     (, la _ xs' xs'') ↦ , la la (∷ a x xs') xs'';
--   };

merge : (A : Type) → (A → A → Bool) → List A → List A → List A;
merge _ _ (nil _) ys ≔ ys;
merge _ _ xs (nil _) ≔ xs;
merge A lessThan (∷ _ x xs) (∷ _ y ys) ≔ 
  ite (List A) (lessThan x y)  
          (∷ A x (merge A lessThan xs (∷ A y ys)))
          (∷ A y (merge A lessThan ys (∷ A x xs)));

-- infixr 5 ++; waiting for implicit arguments
++ : (a : Type) → List a → List a → List a;
++ a (nil _) ys ≔ ys;
++ a (∷ _ x xs) ys ≔ ∷ a x (++ a xs ys);

ltx : (A : Type) → (A → A → Bool) → A → A → Bool;
ltx A lessThan x y ≔ lessThan y x;

gex : (A : Type) → (A → A → Bool) → A → A → Bool;
gex A lessThan x y ≔ not (ltx A lessThan x y) ;

quickSort : (A : Type) → (A → A → Bool) → List A → List A;
quickSort A _ (nil _)         ≔ nil A;
quickSort A _ (∷ _ x (nil _)) ≔ ∷ A x (nil A);
quickSort A lessThan (∷ _ x ys) ≔
  ++ A (quickSort A (filter A ltx) ys)
       (++ A (∷ A x (nil A)) (quickSort A (filter A gex) ys));

-- Mutual recursive function example

aux : (A : Type) → A → List A → List A;
flat : (A : Type) → List A → List A;

aux A (nil _) ls    := flat A ls;
aux A (∷ _ x xs) ls := ∷ A x (aux A xs ls);

flat A (nil _)     := nil A;
flat A (∷ _ x xs)  := aux A x xs;

end;